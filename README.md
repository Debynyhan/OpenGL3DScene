Designing software is a systematic process that involves understanding the problem, planning, creating architectural designs, and detailing specifications before any coding begins. Initially, it involves a deep dive into requirements gathering, ensuring all needs are documented and understood. Following this, feasibility studies are conducted to determine the practicality of the proposed solution, considering technical, financial, and legal implications. 

The next phase involves system design, which is bifurcated into high-level design (HLD) to outline the system architecture, and low-level design (LLD) to detail out the HLD with precise specifications for each component.  

Following the system design phase, is the user-experience design phase. This requires the creation of user personas and wireframes to ensure the software is user centric. This is not merely about aesthetics but rooted in research-based methodologies, to encapsulate the various user types and their needs.  

With a system design in place, the focus shifts to software architectural design. This is where I select the appropriate architecture patterns, such as MVC, MVVM, Microservices, and the suitable data storage solutions, including databases data warehouses and the data model. Component design follows, where the principles of modularity, Single Responsibility Principle, RAII, guide the creation of manageable parts of the system.  

Adopting a shift left approach, I prioritize security for the very beginning of the software development life cycle. This method involves proactively identifying potential threats and embedding robust security protocols early on to safeguard the softwareâ€™s integrity. Alongside this, scalability and performance considerations are integrated from the initial stages of design. 

The development phase is iterative, embracing Agile methodologies for adaptability, continuous integration, and continuous development. Testing is rigorous and automated and is designed to align with the initial requirements. This ensures that the software meets its intended purpose. Throughout the entire design process, thorough documentation is maintained for technical details. 

One key design skill that this project helped me develop was a deeper understanding of the functional programming paradigm. This paradigm emphasizes the use of pure functions and avoids shared state, mutable data, and side-effects. By focusing on the transformation of data through functions, I was able to write clearer and more predictable code. 

Additionally, I embraced the Single Responsibility Principle (SRP), a core concept of object-oriented design, which states that a class should only have one reason to change. This principle guided me to create modular, reusable, and maintainable functions where each function was responsible for a single aspect of the project. For instance, one function was dedicated solely to handling user input, while another was focused on managing textures. 

The tactics from this design approach, such as the emphasis on functional programming, adherence to the SRP and RAII, are universally applicable to future work. In any software project, the ability to write clean, modular code that is easy to test and maintain is invaluable. In future software development tasks, I will continue to apply these principles to ensure high-quality results. Software design best practices and principles will guide the creation of a codebase that is easy to iterate on and extend. 

Iteration played a crucial role in my development process. The creation of complex objects, while integrating incremental changes was pivotal to my final scene. This iterative approach enabled me to progressively enhance functionality and aesthetics of each object.  

Computational graphics and visualization have deepened my problem-solving skills and mathematical insights. They are essential in my educational journey in computer science. These skills open opportunities in fields such as gaming and virtual reality. 
